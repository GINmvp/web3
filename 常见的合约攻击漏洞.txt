1什么是重入攻击，它是如何在智能合约中执行的？
    一个合约在使用call像另一个合约转账，接收交易的合约需要使用fallback或者receive函数来处理。
    接收转账的合约在fallback或者receive函数中恶意的再次调用转账逻辑
    如果被攻击的合约没有处理好相关细节，就会被攻击造成损失

2如何防止智能合约中的重入攻击？
    有三种方式防止重入：
        使用互斥锁，当交易发生重入的时候会被锁拦截；
        使用transfer进行交易，transfer最大的gas上限是2300，如果超过2300，就会失败。
        使用检查-修改-交易的模式，先检查状态，然后修改状态，最后再发送交易。可以有效避免重入攻击。



3.DAO 攻击是如何发生的，它与重入漏洞有什么关系？
    dao攻击就是一次利用智能合约的重入漏洞发动的一次攻击
    攻击者利用重入漏洞转走了大量的ETH，
    虽然最后通过硬分叉追回了部分的ETH，
    但是也将ETH分成了ETH和ETHW

4什么是整数溢出和下溢，它们如何影响智能合约？
    上下溢出是指在进行数值运算时，结果超出了所能表示的范围，导致错误的计算结果。
        上溢出（Overflow）：当一个数值增加到超出其类型的最大值时，例如，将一个 uint8（最大值为 255）加 1，将导致结果回绕到 0。
		下溢出（Underflow）：当一个数值减少到低于其类型的最小值（对于无符号整数为 0）时，例如，将一个 uint8（值为 0）减去 1，会导致结果回绕到 255。
	在 Solidity 0.8.0 版本后，溢出和下溢出检查已被默认启用。


5如何在 Solidity 合约中防止整数溢出和下溢？
    使用openzeppelin的数学安全合约
    当然在 Solidity 0.8.0 版本后，溢出和下溢出检查已被默认启用。

6.如何理解 Solidity 中的可见性关键字，并且它们的误用如何导致合约被攻击？
    public：任何外部调用都可以访问该函数。
    external：只有外部调用可以访问该函数。
    private：只有当前合约内部可以访问该函数。
    internal：当前合约和派生合约可以访问该函数。

    一些不能被外部调用的函数，被错误的设置成了public，导致被攻击造成资损

7什么是委托调用（delegatecall）和它的风险？
    委托调用（delegatecall）是一种特殊的函数调用方式，它允许一个合约在另一个合约的上下文中执行代码。
    这意味着被调用合约的状态变量将影响调用合约，而不是被调用合约自己的状态变量。

    然而，如果不正确使用，它可能会导致合约状态被恶意合约修改，因为 delegatecall 保留了调用合约的 msg.sender 和 msg.value。


8什么是交易顺序依赖性，它如何被利用进行攻击？
    合约的执行结果，依赖于区块中的交易顺序。
    假设此时区块中发生了一笔交易，与此同时恶意攻击者用更高的GasFee提交了一个相反的交易
    由于攻击者更高的GasFee，攻击者的交易可能会被优先打包，导致正常的交易可能会被拒绝。


9在智能合约中如何安全地处理外部调用？


10如何利用以太坊的特性来增强智能合约的安全性？
    使用新的编译期版本，和代码版本。
    新的版本的编译期增强了编译期的代码审查，可以发现一些变量没有正常初始化导致的错误。
    新版本的Solidity解决了整数溢出和下溢的问题

11什么是智能合约中的拒绝服务（DOS）攻击？
    Dos攻击可以把 Ether 永远锁在被攻击的合约中无法取出

12描述一种可能导致智能合约 DOS 攻击的情况?
    假设有一个合约，使用List来保存付款信息
	他需要遍历这个List为每个用户付款
	
	黑客可以往这个list中插入大量的无效的用户地址，导致合约在遍历这个list的时候消耗的Gas超出了区块上限而被拒绝
	这就导致ETH被永远的锁在该合约中无法取出

13智能合约中的“所有者操作”是什么意思？它如何成为安全漏洞？
    合约的某些函数会被设置成仅owner可操作
    但是有时候由于owner的密钥丢失等原因，变得不活跃，无法正常处理业务，导致整个合约不可用

    解决方案是：不依赖单一owner，可以使用多签来替代单一owner


14Solidity 中使用 block.timestamp 可能导致哪些安全问题？
    block.timestamp是获取区块的时间戳，
    但是由于矿工可以操作时间戳，导致一些依赖于时间戳的函数可能被攻击。

    比如链上随机数可能会将时间戳作为种子，矿工会影响时间戳的值，导致攻击者可以控制随机数。
    使用预言机获取随机数是一种较好的替代方案

15构造函数在 Solidity 中的命名与漏洞有何关联？
    老版本中，Solidity的构造函数需要与合约名称相同，如果不相同就会变成普通函数
    可能就会被外部调用

16什么是未初始化的存储指针漏洞？它如何影响智能合约？
    未初始化的存储指针漏洞是指在智能合约中，开发者未对存储结构体或数组进行适当初始化，
    导致合约在执行时可能访问未定义的存储位置，从而导致意外行为或安全漏洞


17为什么在 Solidity 中不推荐使用 tx.origin 进行身份验证？
    安全风险：tx.origin 返回的是交易的原始发送者地址，而不是当前调用者的地址。
        这意味着如果合约 A 调用合约 B，而合约 B 依赖 tx.origin 来验证调用者，合约 A 的地址将被视为调用者，这可能导致意外授权，允许未授权用户执行敏感操作。
    重入攻击：使用 tx.origin 可能会导致合约在外部调用时更容易受到重入攻击。
        攻击者可以构造链式调用，使得 tx.origin 返回的地址不是预期的合约地址，从而绕过安全检查。
    逻辑混淆：依赖 tx.origin 会使合约的逻辑变得复杂和难以理解，增加了审计和维护的难度。开发者可能会误解合约的权限控制，导致安全漏洞。
    与合约调用不兼容：合约通常会调用其他合约，使用 msg.sender 更符合合约之间的调用语义，而 tx.origin 在这种情况下容易导致错误的身份验证结果。

18 Solidity不支持浮点数或定点数的后果是什么？
    Solidity不支持浮点数或定点数是因为浮点数的精度问题
    Solidity使用整数来替代浮点数，
    因此，在处理浮点数时，需要使用数学库来完成，例如使用 SafeMath 库。

19什么是“一次性地址”技术，它如何在以太坊上被利用？
    一次性地址技术涉及构建能够有效签名事务的随机 r 和 s 值（ECDSA 组件），使得派生的以太坊地址被用作交易的发起者。
    这可以用于无需知道私钥的情况下，临时或匿名地管理资金。
20描述如何在智能合约中防止未授权的修改或访问。
    可以使用openzeppelin的Ownable合约，该合约提供了对合约的所有权进行控制，并提供了修改所有权的函数。
    在合约中，只有合约的所有者可以执行某些操作，如修改合约状态或调用其他函数。
    
    当然如果害怕发生由于owner不活跃导致无法正常处理业务，可以采用多签来替代owner。

    也可以使用时间锁来进行自动化操作