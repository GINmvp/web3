1.如下合约中，test 返回什么?
  // SPDX-License-Identifier: MIT
  pragma solidity ^0.8.17;
  contract Demo {
      //当给返回值赋值后，并且有个return，以最后的return为主
      function test() public pure returns (uint256 mul) {
          uint256 a = 10;
          mul = 100;
          return a;
      }
  }
  虽然solidity语言支持命名返回值进行函数返回（这里是给mul赋值），但是在函数的末尾显式的调用了return a。
  如果同时在函数体中显式使用 return 语句，则返回值将以 return 语句的值为主
  因此，尽管 mul 被赋值为 100，最终返回的是 a 的值。

  
2.函数的入参使用时候有哪些需要注意的？
    对于引用类型的入参，要注意其存储方式，适当的使用memory/calldata可以节约Gas
    入参可以当作本地变量使用

3.创建一个 Utils 合约，其中有 sum 方法，传入任意数量的数组，都可以计算出求和结果。

4.函数既可以定义在合约内部，也可以定义在合约外部，两种方式的区别是什么？
  定义在合约内部的函数，是合约的一部分，可以任意访问合约中的状态变量和其他函数

  定义在合约外的函数是外部函数，又叫自由函数。自由函数隐式的拥有 internal 的可见性
  自由函数仍然在合约的上下文中运行，也可以访问 this ，也可以调用其他合约，发送代币等
  但是自由函数内部不能访问合约的状态变量，也不能调用不在他们的作用域范围内函数

5.函数的构造函数有什么特点？
  合约中的构造函数通常用于初始化一些状态变量；
  其特点是在创建合约时被调用，且在合约的整个生命周期中也只会被调用一次
  构造函数不是必须的，且不会被重载

6.构造函数有哪些用途？
  构造函数常用于初始化一些状态变量
  设置合约初始所有权
  

7.合约内调用外部有哪些？
  
  

8.从一个合约到另一个合约的函数调用会创建交易么？


9.调用函数并转帐如何实现
  三种方式：
  recipient.transfer(amount);
  recipient.send(amount);
  recipient.call{value: amount}("");

10.extcodesize 操作码会检查要调用的合约是否确实存在，有哪些特殊情况？
  extcodesize是Solidity 中的一个内联汇编指令，用于获取指定地址上合约代码的字节大小。
  这个指令通常在合约的调用中使用，以检查一个地址是否是合约地址。

  当目标合约正在部署中（正在执行构造函数），此时调用extcodesize会返回 0，因为合约代码尚未被部署
  如果使用低级调用call或者Delegatecall，而目标地址不是一个合约，低级调用仍然会尝试执行，但可能导致失败。

11.与其他合约交互时候有什么需要注意的？
  调用任何三方合约都是有潜在风险的，尤其是不知道目标合约的源码的情况下
  检查合约地址：在调用其他合约之前，使用 extcodesize 检查目标地址是否为合约。避免意外调外部账户；
  处理返回值：在使用低级调用的时候，需要处理调用失败的情况，如果返回值是false，应该处理错误避免出现资损；
  Gas 限制：在调用三方合约时要注意Gas限制，要提供足够的Gas以便执行一些复杂的目标合约，同时也要限制Gas上限，防止目标合约的恶意行为；
  重入攻击：在合约中调用外部合约时，要注意重入攻击的风险。使用检查-效果-交互模式，或者使用互斥锁（如 ReentrancyGuard）来防止重入攻击；
  审计：对于复杂的交互，进行安全性审计是必要的，以发现潜在的漏洞和风险；
  事件日志：在与其他合约交互时，使用事件记录重要的状态变化，以便后续审计和追踪；

12.public 既可以被当作内部函数也可以被当作外部函数。使用时候有什么注意的？
  

13.在函数中，哪些行为被视为读取状态。
  读取状态变量
  调用合约内其他的view函数
  读取区块信息，比如获取当前区块时间戳等
  读取msg的信息，比如msg的地址，金额
  读取地址的余额
  读取合约的日志事件
  访问自动生成的get函数
  使用了某些可能会读取数据的内联汇编

14.pure 函数发生错误时候，有什么需要注意的？
  

15.view 函数中，哪些行为视为修改状态。
      写入状态变量；
			释放事件；
			创建其他合约；
			使用 selfdestruct(自毁函数)；
			通过调用发送以太币；
			调用任何未标记 view 或 pure 的函数；
			使用低级调用（low-level calls）；
			使用包含某些操作码的内联汇编；


16.pure/view/payable/这些状态可变性的类型转换是怎么样的？
    可以将pure转换为view，和non-payable
    view 函数可以转换为 non-payable 函数
    payable 函数可以转换为 non-payable 函数
    其他的转换则不可以

17.使用 return 时，有哪些需要注意的？
  返回类型匹配：确保 return 语句的返回值与函数定义的返回类型匹配。如果类型不匹配，编译器将报错。
  返回多个值：如果函数定义为返回多个值，确保在 return 语句中提供相应数量的值
  默认返回值：如果函数没有显式的 return 语句，且返回类型是 uint、address 或其他值类型，默认返回值为其类型的零值（如 0、空地址等）
  构造函数：构造函数没有返回值，不能使用return
  

18.函数的签名的逻辑是什么？为什么函数可以重载？
  函数名称和参数类型的顺序和数量构成，不包括返回类型。
  function example(uint256 a, string memory b) public {}
  该函数的函数签名时：example(uint256,string)
  而函数选择器是将函数签名经过 Keccak-256 算法计算出签名的摘要然后取前四位

  重载指的是同一个合约内两个函数的函数名相同但是参数类型和顺序不同
  函数何以重载是因为：
    在同一个合约内不允许出现函数签名相同的函数的，也就是说函数签名是唯一的
    而函数签名是函数名称和参数类型的顺序和数量构成
    当两个同名函数，但是入参类型和顺序不同时，他们的函数签名不同
    所以函数可以重载

19.函数重载需要怎么样实现？
  

20.函数重载的参数匹配原理
  当调用一个函数时，EVM 会检查提供的参数的类型和数量，以找到匹配的函数签名。
  EVM 会尝试找到一个完全匹配的函数，即参数的类型和数量都完全相同。如果找到，则调用这个函数
  如果没有找到完全匹配的函数，EVM 会检查是否有可以通过类型转换来匹配的函数。例如，uint8 可以隐式转换为 uint256，但反之则不行。
  如果有多个重载函数可以匹配，就像下面的例子中的 f(uint8 val)和f(uint256 val)，编编译器无法确定到底匹配哪个函数，于是就会在编译期报错
  如果没有找到任何合适的匹配，EVM 会抛出错误，提示调用了不存在的函数。
  
 21.function f(uint8 val) public pure returns (uint8 out) 和 function f(uint256 val) public pure returns (uint256 out) 是合法的函数重载么？
    这么写虽然是一个重载，编译器不会报错
    但是在实际调用的时候假设调用f（8）
    因为8既可以隐式转换成uint8，也可以转换成uint256
    所以在调用这两个重载函数时会报一个无法正确匹配函数的错误

22.函数修改器的意义是什么？有什么作用？
  函数修改器的作用就是将一些重复功能的代码比如owner检查，参数检查等抽离出来作为一个工具
  好处就是将提高代码的复用性，改善编码效率
  减少重复代码
  

23.Solidity 有哪些全局的数学和密码学函数？


